#include <stdio.h>
#include <stdlib.h>


// Print recursively decimal positive number to binary
void DecimalNumberToBinary(int decimal_number){
	if(decimal_number < 2){
		printf("%d" , decimal_number);
	}
	else{
		DecimalNumberToBinary(decimal_number / 2);
		printf("%d", decimal_number % 2);
	}
}

//Recursive pow functions: first - simple way (without optimization); second - with optimization
// Simple way (without optimization
int Recursive_simple_way(int base, int degree){
	if(degree == 1){
		return base;
	}
	else if(degree == 0){
		return 1;
	}
	else if(degree < 0){
		return -1;
	}
	else{
		return base * Recursive_simple_way(base, degree - 1);
	}
}

// Way with optimization
int Recursive_optimization(int base, int degree){
	if(degree == 1){
		return base;
	}
	else if(degree == 0){
		return 1;
	}
	else if(degree % 2 == 0){
		return Recursive_optimization(base, degree / 2) *
				Recursive_optimization(base, degree / 2);
	}
	else if(degree < 0){
		return -1;
	}
	else{
		return base * Recursive_optimization(base, degree - 1);
	}
}

int routes(int y, int x, int ** obstacles){
	if(obstacles[y][x] == 1){
		return 0;
	}
	else{
		if(x == 0 && y == 0){
			return 0;
		}
		else if(x == 0 ^ y == 0){
			return 1;
		}
		else{
			return routes(y - 1, x, obstacles) + routes(y, x - 1, obstacles);
		}
	}
}

int main(void) {
	DecimalNumberToBinary(126);
	printf("\n%d", Recursive_simple_way(2, -10));
	printf("\n%d\n", Recursive_optimization(2, -10));

	const int x_size = 5;
	const int y_size = 5;
	int obstacles[y_size][x_size];
	for(int i = 0; i < y_size; i++){
		for(int j = 0; j < x_size; j++){
			if(i == j){
				obstacles[i][j] = 1;
			}
			else{
				obstacles[i][j] = 0;
			}
			printf("%d ", obstacles[i][j]);
		}
		printf("\n");
	}
	for(int i = 0; i < y_size; i++){
		for(int j = 0; j < x_size; j++){
			printf("%d", routes(i, j, obstacles));
		}
		printf("\n");
	}
	return 0;
}
